setwd("~/git/rcode/DATA 599/code")
library(pipewelder)
# CDC_caching
construct_cdc <- function(sheet) {
if (!"CDC" %in% names(sheet)) {
stop("Input must contain a 'CDC' tab with Series IDs.")
}
cdc_tab <- sheet$CDC
series_ids <- cdc_tab[["Series ID"]]
# Ensure cache directory exists
cache_dir <- file.path(getwd(), "pipewelder_cache")
if (!dir.exists(cache_dir)) {
dir.create(cache_dir)
}
results <- list()
for (i in seq_along(series_ids)) {
series_id <- series_ids[i]
description <- cdc_tab$Description[i]
# Generate MD5 hash for cache key
cache_key <- digest::digest(series_id, algo = "md5")
cache_file <- file.path(cache_dir, paste0("cdc_", cache_key, ".rds"))
message(sprintf("Retrieving CDC dataset: %s", series_id))
# Load from cache or fetch if needed
result <- tryCatch({
if (file.exists(cache_file)) {
readRDS(cache_file)
} else {
data <- get_cdc(series_id)
saveRDS(data, cache_file)
data
}
}, error = function(e) {
warning(sprintf(
"Failed to retrieve CDC series '%s': %s",
series_id,
e$message
))
NULL
})
if (!is.null(result)) {
attr(result, "description") <- description
results[[paste0("CDC_", series_id)]] <- result
}
}
return(results)
}
#' Retrieve All Tabs from a Public Google Sheet
#'
#' Downloads and returns all visible tabs (worksheets) from a publicly shared
#' Google Sheets URL. Returns a named list of tibbles, one per tab, using
#' [googlesheets4::read_sheet()] internally. Automatically handles
#' authentication deauthorization for public sheets, if requested.
#'
#' @param url Character. A publicly shared Google Sheets URL.
#' @param deauth Logical. Whether to disable Google authentication for accessing
#'   public sheets. Defaults to `TRUE`. Set to `FALSE` if you want to use your
#'   own credentials (e.g., for private sheets).
#'
#' @return A named list of tibbles. Each element corresponds to a tab in the
#'   Google Sheet, with the tab name used as the list element name. If a tab
#'   fails to load, a warning is issued and that element will be `NULL`.
#'
#' @examples
#' \dontrun{
#'   url <- "https://docs.google.com/spreadsheets/d/your_public_sheet_id_here"
#'   sheet_data <- get_full_gsheet(url)
#'   names(sheet_data)  # See tab names
#'   sheet_data$Metadata  # Access the "Metadata" tab as a tibble
#' }
#'
#' @seealso [googlesheets4::read_sheet()], [googlesheets4::gs4_deauth()]
#' @export
get_full_gsheet <- function(url, deauth = TRUE) {
if (deauth) {
googlesheets4::gs4_deauth()
}
tab_names <- googlesheets4::sheet_names(url)
sheet_list <- lapply(tab_names, function(tab) {
tryCatch({
googlesheets4::read_sheet(url, sheet = tab)
}, error = function(e) {
warning(paste("Could not read sheet:", tab, "-", e$message))
NULL
})
})
names(sheet_list) <- tab_names
return(sheet_list)
}
construct_bls <- function(sheet,
start_year = 2000,
end_year = as.integer(format(Sys.Date(), "%Y"))) {
# Filter only BLS-related tabs
bls_keys <- grep("^BLS-", names(sheet), value = TRUE)
# Initialize result list
results <- list()
# Iterate over each BLS tab
for (key in bls_keys) {
tab <- sheet[[key]]
# Sanity check: skip if no Series ID column
if (!"Series ID" %in% names(tab))
next
# Iterate over each Series ID in the tab
for (i in seq_len(nrow(tab))) {
series_id <- tab[["Series ID"]][i]
# Skip NA or empty Series ID
if (is.na(series_id) || series_id == "")
next
# Build the name for this dataset
var_name <- paste0(gsub("-", "_", key), "_", series_id)
# Safely call get_bls() and store result
result <- tryCatch({
get_bls(series_id, start_year, end_year)
}, error = function(e) {
warning(sprintf(
"Failed to retrieve BLS series '%s': %s",
series_id,
e$message
))
NULL
})
Sys.sleep(3)
results[[var_name]] <- result
}
}
return(results)
}
#' Retrieve and Construct FRED Series Data
#'
#' Iterates over a list of FRED series IDs from a tab named `"FRED"` in a
#' `sheet` list, retrieving each series using [`get_fred()`] and returning a
#' named list of tibbles. Each tibble includes `date` and `value` columns, and
#' is annotated with a `"description"` attribute.
#'
#' @param sheet A named list that includes an element `"FRED"`: a tibble
#'   containing at minimum a `"Series ID"` column (character vector of FRED
#'   series IDs), and optionally a `"Description"` column for metadata.
#' @param start_date Start date for FRED data, in `"YYYY"`, `"YYYY-MM"`,
#'   `"YYYY-MM-DD"` format, or as a `Date` object. Defaults to `"1950-01-01"`.
#' @param end_date Optional end date for FRED data. Same format as `start_date`.
#'   Defaults to today's date.
#'
#' @return A named list of tibbles, each corresponding to a FRED series. Each
#'   tibble has columns `date` and `value`, and includes a `"description"`
#'   attribute.
#'
#' @examples
#' \dontrun{
#'   # Assuming `sheet` is a list with a "FRED" tibble:
#'   fred_data <- construct_fred(sheet, start_date = "2000-01-01")
#'   attr(fred_data$FRED_UNRATE, "description")
#' }
#'
#' @export
construct_fred <- function(sheet,
start_date = "1950-01-01",
end_date = Sys.Date()) {
if (!"FRED" %in% names(sheet)) {
stop("Input must contain a 'FRED' tab with Series IDs.")
}
fred_tab <- sheet$FRED
series_ids <- fred_tab[["Series ID"]]
results <- list()
for (i in seq_along(series_ids)) {
series_id <- series_ids[i]
description <- fred_tab$Description[i]
message(sprintf("Retrieving FRED series: %s", series_id))
result <- tryCatch({
get_fred(series_id, start_date, end_date)
}, error = function(e) {
warning(sprintf(
"Failed to retrieve FRED series '%s': %s",
series_id,
e$message
))
NULL
})
if (!is.null(result)) {
attr(result, "description") <- description
results[[paste0("FRED_", series_id)]] <- result
}
}
return(results)
}
#' Construct CDC Data
#'
#' Iterates over the CDC tab and retrieves all listed datasets using
#' \code{get_cdc()}. Each result is stored in a named list, with a description
#' attribute attached for later reference.
#'
#' @param sheet A named list from \code{get_full_gsheet()}, containing a "CDC"
#'   element. This tab must include at least two columns: "Series ID" and
#'   "Description".
#'
#' @return A named list of tibbles retrieved from CDC's Socrata endpoints. Each
#'   tibble will have a "description" attribute containing its metadata label.
#' @export
# construct_cdc <- function(sheet) {
#   if (!"CDC" %in% names(sheet)) {
#     stop("Input must contain a 'CDC' tab with Series IDs.")
#   }
#
#   cdc_tab <- sheet$CDC
#   series_ids <- cdc_tab[["Series ID"]]
#
#   results <- list()
#
#   for (i in seq_along(series_ids)) {
#     series_id <- series_ids[i]
#     description <- cdc_tab$Description[i]
#
#     message(sprintf("Retrieving CDC dataset: %s", series_id))
#
#     result <- tryCatch({
#       get_cdc(series_id)
#     }, error = function(e) {
#       warning(sprintf(
#         "Failed to retrieve CDC series '%s': %s",
#         series_id,
#         e$message
#       ))
#       NULL
#     })
#
#     if (!is.null(result)) {
#       attr(result, "description") <- description
#       results[[paste0("CDC_", series_id)]] <- result
#     }
#   }
#
#   return(results)
# }
# Code
url <- "https://docs.google.com/spreadsheets/d/1PhW5-z7LqLg-HxwwbXQ524fw-0gDhlHEbvUn93raciE/edit?usp=sharing"
sheet <- get_full_gsheet(url)
# CDC_caching
construct_cdc <- function(sheet) {
if (!"CDC" %in% names(sheet)) {
stop("Input must contain a 'CDC' tab with Series IDs.")
}
cdc_tab <- sheet$CDC
series_ids <- cdc_tab[["Series ID"]]
# Ensure cache directory exists
cache_dir <- file.path(getwd(), "pipewelder_cache")
if (!dir.exists(cache_dir)) {
dir.create(cache_dir)
}
results <- list()
for (i in seq_along(series_ids)) {
series_id <- series_ids[i]
description <- cdc_tab$Description[i]
# Generate MD5 hash for cache key
cache_key <- digest::digest(series_id, algo = "md5")
cache_file <- file.path(cache_dir, paste0("cdc_", cache_key, ".rds"))
message(sprintf("Retrieving CDC dataset: %s", series_id))
# Load from cache or fetch if needed
result <- tryCatch({
if (file.exists(cache_file)) {
readRDS(cache_file)
} else {
data <- get_cdc(series_id)
saveRDS(data, cache_file)
data
}
}, error = function(e) {
warning(sprintf(
"Failed to retrieve CDC series '%s': %s",
series_id,
e$message
))
NULL
})
if (!is.null(result)) {
attr(result, "description") <- description
results[[paste0("CDC_", series_id)]] <- result
}
}
return(results)
}
construct_cdc(sheet)
library(pipewelder)
#' Retrieve All Tabs from a Public Google Sheet
#'
#' Downloads and returns all visible tabs (worksheets) from a publicly shared
#' Google Sheets URL. Returns a named list of tibbles, one per tab, using
#' [googlesheets4::read_sheet()] internally. Automatically handles
#' authentication deauthorization for public sheets, if requested.
#'
#' @param url Character. A publicly shared Google Sheets URL.
#' @param deauth Logical. Whether to disable Google authentication for accessing
#'   public sheets. Defaults to `TRUE`. Set to `FALSE` if you want to use your
#'   own credentials (e.g., for private sheets).
#'
#' @return A named list of tibbles. Each element corresponds to a tab in the
#'   Google Sheet, with the tab name used as the list element name. If a tab
#'   fails to load, a warning is issued and that element will be `NULL`.
#'
#' @examples
#' \dontrun{
#'   url <- "https://docs.google.com/spreadsheets/d/your_public_sheet_id_here"
#'   sheet_data <- get_full_gsheet(url)
#'   names(sheet_data)  # See tab names
#'   sheet_data$Metadata  # Access the "Metadata" tab as a tibble
#' }
#'
#' @seealso [googlesheets4::read_sheet()], [googlesheets4::gs4_deauth()]
#' @export
get_full_gsheet <- function(url, deauth = TRUE) {
if (deauth) {
googlesheets4::gs4_deauth()
}
tab_names <- googlesheets4::sheet_names(url)
sheet_list <- lapply(tab_names, function(tab) {
tryCatch({
googlesheets4::read_sheet(url, sheet = tab)
}, error = function(e) {
warning(paste("Could not read sheet:", tab, "-", e$message))
NULL
})
})
names(sheet_list) <- tab_names
return(sheet_list)
}
construct_bls <- function(sheet,
start_year = 2000,
end_year = as.integer(format(Sys.Date(), "%Y"))) {
# Filter only BLS-related tabs
bls_keys <- grep("^BLS-", names(sheet), value = TRUE)
# Initialize result list
results <- list()
# Iterate over each BLS tab
for (key in bls_keys) {
tab <- sheet[[key]]
# Sanity check: skip if no Series ID column
if (!"Series ID" %in% names(tab))
next
# Iterate over each Series ID in the tab
for (i in seq_len(nrow(tab))) {
series_id <- tab[["Series ID"]][i]
# Skip NA or empty Series ID
if (is.na(series_id) || series_id == "")
next
# Build the name for this dataset
var_name <- paste0(gsub("-", "_", key), "_", series_id)
# Safely call get_bls() and store result
result <- tryCatch({
get_bls(series_id, start_year, end_year)
}, error = function(e) {
warning(sprintf(
"Failed to retrieve BLS series '%s': %s",
series_id,
e$message
))
NULL
})
Sys.sleep(3)
results[[var_name]] <- result
}
}
return(results)
}
#' Retrieve and Construct FRED Series Data
#'
#' Iterates over a list of FRED series IDs from a tab named `"FRED"` in a
#' `sheet` list, retrieving each series using [`get_fred()`] and returning a
#' named list of tibbles. Each tibble includes `date` and `value` columns, and
#' is annotated with a `"description"` attribute.
#'
#' @param sheet A named list that includes an element `"FRED"`: a tibble
#'   containing at minimum a `"Series ID"` column (character vector of FRED
#'   series IDs), and optionally a `"Description"` column for metadata.
#' @param start_date Start date for FRED data, in `"YYYY"`, `"YYYY-MM"`,
#'   `"YYYY-MM-DD"` format, or as a `Date` object. Defaults to `"1950-01-01"`.
#' @param end_date Optional end date for FRED data. Same format as `start_date`.
#'   Defaults to today's date.
#'
#' @return A named list of tibbles, each corresponding to a FRED series. Each
#'   tibble has columns `date` and `value`, and includes a `"description"`
#'   attribute.
#'
#' @examples
#' \dontrun{
#'   # Assuming `sheet` is a list with a "FRED" tibble:
#'   fred_data <- construct_fred(sheet, start_date = "2000-01-01")
#'   attr(fred_data$FRED_UNRATE, "description")
#' }
#'
#' @export
construct_fred <- function(sheet,
start_date = "1950-01-01",
end_date = Sys.Date()) {
if (!"FRED" %in% names(sheet)) {
stop("Input must contain a 'FRED' tab with Series IDs.")
}
fred_tab <- sheet$FRED
series_ids <- fred_tab[["Series ID"]]
results <- list()
for (i in seq_along(series_ids)) {
series_id <- series_ids[i]
description <- fred_tab$Description[i]
message(sprintf("Retrieving FRED series: %s", series_id))
result <- tryCatch({
get_fred(series_id, start_date, end_date)
}, error = function(e) {
warning(sprintf(
"Failed to retrieve FRED series '%s': %s",
series_id,
e$message
))
NULL
})
if (!is.null(result)) {
attr(result, "description") <- description
results[[paste0("FRED_", series_id)]] <- result
}
}
return(results)
}
#' Construct CDC Data
#'
#' Iterates over the CDC tab and retrieves all listed datasets using
#' \code{get_cdc()}. Each result is stored in a named list, with a description
#' attribute attached for later reference.
#'
#' @param sheet A named list from \code{get_full_gsheet()}, containing a "CDC"
#'   element. This tab must include at least two columns: "Series ID" and
#'   "Description".
#'
#' @return A named list of tibbles retrieved from CDC's Socrata endpoints. Each
#'   tibble will have a "description" attribute containing its metadata label.
#' @export
# construct_cdc <- function(sheet) {
#   if (!"CDC" %in% names(sheet)) {
#     stop("Input must contain a 'CDC' tab with Series IDs.")
#   }
#
#   cdc_tab <- sheet$CDC
#   series_ids <- cdc_tab[["Series ID"]]
#
#   results <- list()
#
#   for (i in seq_along(series_ids)) {
#     series_id <- series_ids[i]
#     description <- cdc_tab$Description[i]
#
#     message(sprintf("Retrieving CDC dataset: %s", series_id))
#
#     result <- tryCatch({
#       get_cdc(series_id)
#     }, error = function(e) {
#       warning(sprintf(
#         "Failed to retrieve CDC series '%s': %s",
#         series_id,
#         e$message
#       ))
#       NULL
#     })
#
#     if (!is.null(result)) {
#       attr(result, "description") <- description
#       results[[paste0("CDC_", series_id)]] <- result
#     }
#   }
#
#   return(results)
# }
# Code
url <- "https://docs.google.com/spreadsheets/d/1PhW5-z7LqLg-HxwwbXQ524fw-0gDhlHEbvUn93raciE/edit?usp=sharing"
sheet <- get_full_gsheet(url)
# CDC_caching
construct_cdc <- function(sheet) {
if (!"CDC" %in% names(sheet)) {
stop("Input must contain a 'CDC' tab with Series IDs.")
}
cdc_tab <- sheet$CDC
series_ids <- cdc_tab[["Series ID"]]
# Ensure cache directory exists
cache_dir <- file.path(getwd(), "pipewelder_cache")
if (!dir.exists(cache_dir)) {
dir.create(cache_dir)
}
results <- list()
for (i in seq_along(series_ids)) {
series_id <- series_ids[i]
description <- cdc_tab$Description[i]
# Generate MD5 hash for cache key
cache_key <- digest::digest(series_id, algo = "md5")
cache_file <- file.path(cache_dir, paste0("cdc_", cache_key, ".rds"))
message(sprintf("Retrieving CDC dataset: %s", series_id))
# Load from cache or fetch if needed
result <- tryCatch({
if (file.exists(cache_file)) {
readRDS(cache_file)
} else {
data <- get_cdc(series_id)
saveRDS(data, cache_file)
data
}
}, error = function(e) {
warning(sprintf(
"Failed to retrieve CDC series '%s': %s",
series_id,
e$message
))
NULL
})
if (!is.null(result)) {
attr(result, "description") <- description
results[[paste0("CDC_", series_id)]] <- result
}
}
return(results)
}
